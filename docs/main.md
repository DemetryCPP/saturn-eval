Тут кратко описан принцип работы калькулятора.

# Лексер
После получения входной строки ее надо обработать. Этим занимается Лексер, который должен вернуть массив токенов. Токен - тип + какие то данные (лексема). В данном случае используется 5 типов токенов:

+ Цифра (0-9)
+ Оператор (в коде можно создавать и удалять операторы, в этом [    файле](https://github.com/DemetryF/evaluate-mathematic-expressions/blob/master/eval/solve/operators.c))
+ Десятичный разделитель (десятичная точка, ".")
+ Скобка "(" или ")"
+ Текст a-z A-Z

так же существует нулевой токен, для нас сейчас он ничего не значит.

# Парсер
Парсер (синтаксический анализатор) - составляет дерево парсинга. Это дерево парсинга является "моделью" выражения, с которой уже можно работать компьютеру.

Принцип простой:
Если выражение в скобках, они убираются. После этого специальная [функция](https://github.com/DemetryF/evaluate-mathematic-expressions/blob/master/eval/parser/find_divider_pos.c) ищет позицию для разделения строки, позицию разделяющего оператора. Принцип такой, функция проходится по массиву токенов с конца, и ищет оператор самый близкий к концу и с самым наименьшим оператором. Операторы в скобках игнорируются. В итоге, дерево парсинга с обратной стороны (с лепестков к голове) имеет правильную последовательность действий.

# Солвер
Solve - решить, он "решает" пример. Обрабатывает дерево парсинга, и получает конечный ответ. Используется алгоритм обхода дерева. Во время обработки ветки используются разветвления ветки. А если конкретнее, функция сразу вычесляет значения своих разветвлений, а потом обрабатывает их.